---
date: 2026-02-12T12:00:00+08:00
title: C
draft: false
# bookFlatSection: false        # 是否显示扁平章节（默认false）
# bookToc: true                 # 是否显示目录（默认true）
# bookHidden: false             # 是否在侧边栏列表中隐藏（默认false）
# bookCollapseSection: false    # 章节是否默认折叠（默认false）
# bookComments: false           # 是否启用评论（默认false）
# bookSearchExclude: false      # 是否从搜索结果中排除（默认false）
# params:                       # 自定义参数
#   maths: true                 # 数学公式支持
# weight: 1                     # 内容权重（排序用）
---

# C 语言环境安装

## 编辑器

编辑器使用最简单的 notepad++

## 编译器

编译器将的 c 语言代码编译为可执行的程序。

windows 环境编译器 MinGW -w64 下载地址：https://www.mingw-w64.org/downloads/，选择“Source - Source Forge”

linux 环境下：

* 编译 C 语言使用 gcc 命令
* 编译 C++ 语言使用 g++ 命令

## IDE

IDE 选择 VSCode

## C 语言版本发展

* 1989 年 ANSI 发布了一个标准：ANSI C
* 1990 年 ISO 接受了 ANSI 的标准：C89
* C 的标准在 1995 年和 1999 年的两次更新：C95 和 C99（最新版本）

## C 语言使用排名

https://www.tiobe.com/tiobe-index/

# 编译过程

源代码 -> 预处理 -> 预编译 -> 目标文件（*.o, *.obj） -> 链接 -> 可执行程序文件

# 语法基础

## 程序框架

每一个 C 语言源代码都会存在的程序框架

```c
# include "stdio.h"

int main(void)
{
    return 0;
}
```

```c
指令：在编译前修改程序的编辑命令。所有的指令都以字符#开始，指令结尾没有分号或其他特殊标记。

int main(void) 函数：被命名的可执行代码块。虽然C程序可以包含多个函数，但只有main函数是必须有的。
{
    语句：程序运行时执行的命令。每条语句都要以分号;结尾。
}
```

## 变量

### 变量定义

```c
// <变量类型> <变量名>;
/* 变量类型包括：
 * short
 * int
 * long
 * float：有一些缺陷，float类型存储的数值往往是实际数值的一个近似值，例如0.1实际存储的可能是0.09999999997
 */ 
```

### 变量初始化

```c
// <变量类型> <变量名> = <初始值>;
// C 语言中变量没有默认值，需要进行初始化赋值操作。
// 如果变量没有初始化，那么变量的值就等于原本内存地址中的值。
```



```c
// 初始值
int c = 0;

```



## C 语言保留字

```c
auto; // 
break;
case;
char;
const;
continue;
default;
do;
double;
else;
enum;
extern;
float;
for;
goto;
if;
int;
long;
register;
return;
short;
signed;
sizeof;
static;
struct;
switch;
typedef;
union;
unsigned;
void;
volatile;
while;
inline;
restrict;
```



# 编译

函数的声明在 *.h 中

函数的实现在 *.c 中

要调用的时候加上头文件即可

gcc -c *.c 只编译

gcc *.o -o outputName.exe 链接

# makefile

qt、java 编译器用的也是 makefile

# printf函数

printf 函数被设计用来显示格式串（format string）的内容，并且在该串中的指定位置插入可能的值。调用 printf 函数时必须提供格式串，格式串后面的参数是需要在显示时插入到该串中的值：

```c
printf(格式串，表达式1，表达式2，...);
```

显示的值可以是常量、变量或者更加复杂的表达式。调用printf函数一次可以打印的值的个数没有限制。

格式串包含普通字符和`转换说明（conversion specifcaton）`，其中转换说明以字符`&`开头。转换说明是用来表示打印过程中待填充的值的占位符。跟随在字符`&`后边的信息指定了把数值从内部形式（二进制）转换成打印形式（字符）的方法。

```c
%、标志、最小字段宽度、精度、长度修饰符、转换说明符
```



## 转换说明

一般地，转换说明可以用`%m.pX`格式或`%-m.pX`格式，这里的m和p都是整数常量，而X是字母。m和p都是可选的。如果省略p，m和p之间的小数点也要去掉。

**最小字段宽度(minimum feld width)**：m指定了要显示的最少字符数量。如果要显示的数值所需的字符数少于m，那么值在字段内是右对齐的（换句话说，在值前面放置额外的空格）。如果要显示的值所需的字符数多于m，那么字段宽度会自动扩展为所需的尺寸。在m前放上一个负号会导致左对齐。

**精度(precision)**：p的含义很难描述，因为它依赖于转换说明符(conversionspecifer)X的选择。X表明在显示数值前需要对其进行哪种转换。对数值来说最常用的转换说明符有以下几个：

* d--表示十进制形式的有符号int整数。p指明了待显示的数字的最少个数（必要时在数前加上额外的零）；如果省略p，则默认它的值为1。
* u--表示十进制形式的无符号int整数。
* o--表示八进制形式的无符号int整数。
* x--表示十六进制形式的无符号int整数。
* hd hu ho hx--表示十、十、八、十六进制形式的有、无、无、无符号short整数。
* ld lu lo lx--表示十、十、八、十六进制形式的有、无、无、无符号long整数。
* lld llu llo llx--表示十、十、八、十六进制形式的有、无、无、无符号long long整数。
* e--表示指数（科学记数法）形式的float浮点数。p指明了小数点后应该出现的数字的个数（默认值为6）。如果p为0，则不显示小数点。
* f--表示“定点十进制”形式的float浮点数，没有指数。p的含义与在说明符e中的一样。
* g --表示指数形式或者定点十进制形式的浮点数，形式的选择根据数的大小决定。p说明可以显示的有效数字（没有小数点后的数字）的最大数量。与转换说明符不同，g的转换将不显示尾随的零。此外，如果要显示的数值没有小数点后的数字，g就不会显示小数点。
* le lf lg--double浮点数
* Le Lf Lg--long double浮点数

## 转义序列

转义序列使字符串包含一些特殊字符而不会使编译器引发问题。

* \a：警报（响铃）符。输出时会产生一声鸣响。
* \b：回退符。输出时会把光标从当前位置回退一个位置。
* \n：换行符。输出时会把光标跳转到下一行的起始位置。
* \t：水平制表符。输出时会把光标跳转到下一个水平制表符的位置。
* \v：垂直制表符。
* \r：回车符。
* \b：回退符。

# scanf函数

scanf函数的用法和printf函数的用法本质上是一样的。
scanf函数根据特定的格式读取输入，格式串包含普通字符和转换说明两部分。

## 转换说明

```c
int i, j;
float x, y;
scanf("%d%d%f%f", i, j, x, y);
printf("%d%d%f%f", i, j, x, y);

// 1 -20 .3 -3.2e3
```

scanf函数本质上是一种“模式匹配”函数，试图把输入的字符组和转换说明相匹配。

* scanf函数从左边开始处理字符串中的信息。对于格式串中的每一个转换说明，scanf函数从输入的数据中定位适当类型的项，并在必要时跳过空格。
* 然后，scanf函数读入数据项，并且在遇到不可能属于此项的字符时停止。如果读入数据项成功，那么scanf函数会继续处理格式串的剩余部分；如果某一项不能成功读入，那么scanf函数将不再查看格式串的剩余部分（或者余下的输入数据）而立即返回。
* 在寻找数的起始位置时，scanf函数会忽略空白字符(white-spacecharacter，包括空格符、水平和垂直制表符、换页符和换行符)。因此，我们可以把数字放在同一行或者分散在几行内输入。由于scanf函数会忽略空白字符，因此在处理回车时一般使用getchar函数。

```c
// 1 
// -20      .3
// -3.2e3
```

* 处理格式串中的普通字符时，scan函数采取的动作依赖于这个字符是否为空白字符。
* 空白字符。当在格式串中遇到一个或多个连续的空白字符时，scanf函数从输入中重复读空白字符直到遇到一个非空白字符(把该字符“放回原处”)为止。格式串中空白字符的数量无关紧要，格式串中的一个空白字符可以与输入中任意数量的空白字符相配（包括零个）。
* 其他字符。当在格式串中遇到非空白字符时，scanf函数将把它与下一个输入字符进行比较。如果两个字符相匹配，那么scanf函数会放弃输入字符而继续处理格式串。如果两个字符不匹配，那么scanf函数会把不匹配的字符放回输入中，然后异常退出，而不进一步处理格式串或者从输入中读取字符。

```c
int i, j;
scanf(" %d / %d", &i, &i);
printf("%d %d", i, j);
// 输入 5 / 95 打印 5 95
// 输入 5 、 95 打印 5 127
```

# 运算符

## 算数运算符

* 一元运算符：只需要一个操作数

  * +：一元正号运算符
  * -：一元负号运算符

* 二元运算符：需要两个操作数

  * +：加法运算符

  * -：减法运算符

  * *：乘法运算符

  * /：除法运算符

    右操作数不能为0，否则会导致未定义行为。

  * %：求余运算符

    求余运算要求两个操作数为整数，否则会编译报错。

    右操作数不能为0，否则会导致未定义行为。

    用于负操作数时，其结果可能向上取整，也可能向下取整。

```tex
由实现定义：C标准故意对C语言的部分内容未加指定，并认为其细节可以由“实现”来具体定义。所谓实现，是指程序在特定平台上编译、链接和执行所需要的软件。因此，根据实现的不同，程序的行为可能会稍有差异。
```

运算符的结合性：

* 左结合：运算符是从左向右结合的。
* 有结合：运算符是从右向左结合的。

## 赋值运算符

* =：赋值运算符要求它的左操作数必须是左值（lvalue），表示存储在计算机内存中的对象，而不是常量或计算的结果。
* 赋值运算符是右结合的。

## 自增

* 前缀自增/自减：自增/自减后的结果
* 后缀自增/自减：语句执行后，再自增/自减
* 在表达式语句的末尾，语句中所有的自增和自减操作都必须执行完毕，否则不能执行下一条语句。

```c
int i = 0;
printf("%d\n", i++); // 输出0
printf("%d\n", i);   // 输出1
i = 0;
printf("%d\n", ++i); // 输出1
i = 0;
printf("%d %d\n", i++, ++i); // 输出 1 2
```

后缀自增/自减（++i/--i）比一元的正号、负号优先级高，而且都是左结合的。
前缀自增/自减（++i/--i）和一元的正号、负号优先级相同，而且都是右结合的。

## 关系运算符

<、>、<=、<=

* 关系运算符产生 结果是0（假）或1（真）。
* 关系运算符的优先级低于算数运算符。
* 关系运算符都是左结合的。

## 判等运算符

==、!=

* 判等运算符产生 结果是0（假）或1（真）。
* 判等运算符的优先级低于算数运算符。
* 判等运算符都是左结合的。

## 逻辑运算符

!、&&、||

* 逻辑运算符产生 结果是0（假）或1（真）。
* !的优先级等于一元运算符。
* &&、||的优先级低于算数运算符。
* !是右结合的。
* &&、||是左结合的。

## 选择语句

* if

  ```c
  if (表达式) {
      多条语句；
      // 单条语句可以省略花括号
  } else if (表达式){
      语句；
  } else {
      语句；
  }
  ```

* switch

  ```c
  switch (表达式) {
      case 常量表达式1:
          // 常量表达式必须是整数，不能是浮点数或字符串
          // 当多个常量表达式需要执行同一段语句时，可以串联case
          // 例如 case 1: case 2: case 3: 语句; break;
          语句;
          break;
      case 常量表达式2:
          语句;
          break;
      ……
      default:
          语句;
          break;
  }
  ```


## 条件运算符（三元运算符）

条件运算符可以简化选择语句。

 ```c
 表达式1 ？ 表达式2 : 表达式3
 // 当表达式1成立，则执行表达式2，否则执行表达式3
 ```

## 重复语句

* while

  ```c
  while (表达式) {
      多条语句；
      // 单条语句可以省略花括号
  }
  ```

  无限循环：如果控制表达式的值始终非零，while语句将无法终止。C程序员有时故意用非零常量作为控制表达式来构造无限循环。

  ```c
  while (1) {
      ……
  }
  ```

* do …… while

  do while 语句本质上就是while语句，只不过是在完成循环体执行之后再判定控制表达式。

  ```c
  do {
      多条语句；
      // 单条语句可以省略花括号
  } while (表达式);
  ```

* for

  ```c
  for (表达式1; 表达式2; 表达式3) {
      // 表达式1是循环开始执行前的初始化步骤，只执行1次
      // 表达式2用来控制循环的终止（只要表达式2的值不为0，循环持续执行）
      // 表达式3是每次循环中最后被执行的一个操作
      多条语句；
      // 单条语句可以省略花括号
  }
  ```

  for 语句可以等价于以下 while 语句：

  ```c
  表达式1;
  while (表达式2) {
      语句;
      表达式3;
  }
  ```

## 逗号运算符

有时候，程序员希望编写多个初始表达式的for语句，或者向再每次循环时对多个变量进行自增操作，使用逗号表达式作为for语句中第1个或第3个表达式可以实现这些想法。

```c
表达式1, 表达式2
for (int i = 1, j = 2, k, k = i + j; i < j; i++, ++i, j++) {
    ……
}
```

## 跳转语句

* break

  用于跳出switch选择，while、do或for循环。

  只能跳出一层。

* continue

  用于跳过某次循环的语句，继续执行下一次循环。

* goto

  可以控制跳转到任何有标号的语句处，既可以向前跳转，又可以向后跳转。

  标号是放置在语句开始处的标识符。

  ```c
  for (int i = 0; i < 20; i++) {
      if (i = 10) {
      	goto don;
  	}
      printf("this is %d.\n", i);
  }
  don:
  printf("goto here");
  ```

# 数据类型

## 整数类型

* short int long数据类型根据CPU能处理的最大位数，会有不同的数据区间。
* short int：-2^15 ~ 2^15-1，可以缩写为 short
* unsigned short int：0 ~ 2^16-1
* int：-2^31 ~ 2^31-1
* unsigned int：0 ~ 2^32-1
* long int：-2^63 ~ 2^63-1，可以缩写为 long
* unsigned long int：0 ~ 2^64-1
* long long int：-2^63 ~ 2^63-1，至少64位宽
* unsigned long long int：0 ~ 2^64-1，至少64位宽

进制：

* 十进制：0-9，不能以零开头
* 八进制：0-7，必须以零开头
* 十六进制：0-9，a-f，必须以0x开头

## 浮点类型

* 浮点类型数据范围是由指数的位数决定的，精度是由尾数的尾数来决定的。

* float：符号1位，指数8位，小数23位，总长度32位

  数据区间：-2^128 ~ 2^127，

  精度区间：2^23 =8388608，一共7位，因此精度6 - 7个十进制数字

* double：符号1位，指数11位，小数52位，总长度64位

  数据区间：-2^1024 ~ 2^1023，

  精度区间：2^52 =4503599627370496，一共16位，因此精度15 - 16个十进制数字

* long double：符号1位，指数11位，小数52位，总长度128位

## 字符类型

char类型本质上是int类型

* signed char：-128~127
* unsigned char：0-255

## 类型转换

在执行算数运算时，计算机要求操作数具有相同的大小（位数相同），且存储的方式相同。
计算机不能直接将16位整数和32位整数相加，也不能直接将32位整数和32位浮点数相加。

C语言允许在表达式中混合使用基本类型，这种情况下C编译器会生成一些指令将操作数转换成相同的类型，这类转换称为隐式转换。隐式转换包括以下四种情况：

* 算数表达式或逻辑表达式中操作数的类型不相同时。

  常用策略是把操作数从较小的数据类型转换为较大的数据类型。

* 赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。

  将右侧表达式的类型转换成左侧变量的类型。

* 函数调用中的实参类型和形参类型不匹配时。

* 函数return表达式类型和返回值类型不匹配时。

C语言还允许程序员使用强制运算符执行显式转换：

```c
(类型名) 表达式
// (类型名)被视为一元运算符。
```

## 类型定义

C语言允许定义类型。

```c
typedef 类型 类型名;
// 类型可以是任意一种已经定义的类型，可以增加程序的可读性和可移植性
// typedef float dollar;
// sizeof() 函数可以用来计算类型所需要的存储空间，sizeof函数的类型是size_t，这是一种由实现定义的类型。
```

# 数组

* 当函数声明数组作为形式参数时，实际参数是指向数组首个元素的指针，而不是在函数的作用域内创建整个数组元素。

  数组的大小会在在这个过程中丢失。

  ```c
  // 以下两个函数声明的实际效果是等价的
  void test1(int arr[]);
  void test2(int *arr);
  ```

  

# 指针

* 声明指针变量 变量类型 *p
* 指针变量赋值/取值，是指针变量指向对象的内存地址 p = 
* 指针变量指向对象赋值/取值，是指针变量指向对象的内存地址存放的数据 *p = 

使用指针前要初始化指针，动态分配内存空间；不再使用指针，要释放内存空间。



对于指针的指针，需要先初始化指针的指针，再初始化指针。举例如下：

```c
int i = 3;
int j = 4;
int **p = malloc(i * (int **)sizeof(int *));
for(int k = 0; k < i; k++){
    p[k] = malloc(j * (int *)sizeof(int));
}
```

在C语言中，使用数组表示的字符串是可变的，而使用指针表示的字符串是不可变的。

# 声明

`声明说明符 声明符`

声明说明符分为4类：

* 存储类型：auto、static、extern、register

  * auto变量具有自动存储期限、块作用域，无链接，几乎从不主动声明

  * static变量用于块外部时，具有内部链接；用于块内部时，具有静态存储期限

  * 声明函数时使用static说明函数具有内部链接，仅允许文件内部调用此函数。

  * extern存储类型使接源文件可以共享同一个变量。变量始终具有静态存储期限。如果声明在块内部，那么变量具有块作用域，否则具有文件作用域。

    声明函数时使用extern说明函数具有外部链接，允许其他文件调用此函数。

    声明函数时，默认情况下（未声明static或extern）函数具有外部链接。

  * register变量存储在寄存器中，而不是内存中，最好用于需要频繁访问或更新的变量。变量在块内有效，和auto具有一样的存储期限、作用域和链接。

* 类型限定符：const、volatile、restrict

  * const用来声明只读变量，程序可以访问const对象的值，但是无法改变它的值
  * volatile只用在底层编程
  * restrict只用在指针，如果指针p指向对象在之后需要修改，那么该对象不允许通过除了指针p之外的任何方式访问

* 类型说明符：void、char、short、int、long、float、double、signed、unsigned、struct、union、enum、typedef

* 函数说明符：inline

  * inline建议编译器使函数尽可能地快，编译器把函数的每一次调用都用函数的机器指令来代替。这种方法使得编译程序的大小增加一些，但是可以避免函数调用的常见额外开销

声明符包括：

* 标识符（简单变量的名字）

* 后面跟随[ ]的标识符（数组名）

* 前面放置*的标识符（指针名）

* 后面跟随( )的标识符（函数名）

* 始终从内往外读标识符，定位声明的标识符，从此处开始解释声明，在做选择时，始终使[ ]和( )优先于*：

  如果 * 在 [ ] 前面，那么表示数组而不是指针

  如果 * 在 ( ) 前面，那么表示函数而不是指针

* C 语言中有一些不可能的声明：

  * 函数不能返回数组，但可以返回指向数组的指针
  * 函数不能返回函数，但可以返回指向函数的指针
  * 数组不能包含函数，但可以包含指向函数的指针

块 block：标识函数体（花括号包含的部分）或者复合语句（可能包含声明）

C程序中的每个变量具有以下3个性质：

* 存储期限：变量的存储期限决定了为变量预留和内存被释放的时间。

  具有自动存储期限auto的变量在所属块被执行时获得内存单元，并在块终止时释放内存单元。没有默认的初始值。

  具有静态存储期限static的变量在程序运行期间占有同一个存储单元，允许变量无限期地保留它的值。默认的初始值为零。

* 作用域：变量的作用域是指可以引用变量的程序部分。

  具有块作用域的变量从声明的地方一直到所在块的末尾都是可见的。

  具有文件作用域的变量从声明的地方一直到所在文件的末尾都是可见的。

* 链接：变量的链接确定了程序的不同部分可以共享此变量的范围。

  具有外部链接的变量可以被程序中的几个（或许全部）文件共享。

  具有内部链接的变量只能属于单独一个文件，但是此文件中的函数可以共享这个变量。

  具有无链接的变量属于单独一个函数，不能被共享。

  链接为链接器服务。

* 在块（包括函数体）内部声明的变量默认具有自动存储期限、块作用域和无链接。（包括main函数）

* 在程序的最外层（任意块外部）声明的变量默认具有静态存储期限、文件作用域和外部链接。

# 函数

C函数所有参数均以“传值调用”方式进行传递，这意味着函数将获得参数值的一份拷贝。函数可以修改这个拷贝值。

如果被传递的参数是一个数组名（数组名的值实际上是一个指针），传递给函数的就是这个指针的一份拷贝。通过被拷贝的指针可以访问数组元素。

在函数中修改被拷贝的指针所指向的对象，在函数调用结束后，释放被拷贝的指针，因此不会影响原始指针所指向的对象。

# 标准库函数

## <stdio.h>

* printf()：
* scanf()：读取输入，跳过空白字符，在任意空白字符停止
* getchar()：getchar函数调用时将读入一个字符并返回。
* putchar(para)：putchar函数调用时将写一个字符
* sizeof(para)：sizeof函数调用时计算存储属于类型名的值所需要的字节数，返回无符号整数
* puts()：输出字符串，并在输出结束的位置额外打印换行符\n
* gets()：读取字符串，在开始前跳过空白字符，直到遇到换行符\n后停止

## <cyper.h>

* toupper(para)：toupper函数在被调用时检测参数是否是小写字母。如果是，会把参数转换成对应的大写字母；否则，会返回参数的值
* 

## <time.h>

* time()：返回当前的时间，用一个数表示

## <stdlib.h>

* srand()：初始化C语言的随机数生成器。通过把time函数的返回值传递给srand可以避免程序在每次运行时发一样的牌，该函数不返回任何值
* rand()：在每次调用时会产生一个看似随机的数，返回一个范围在 0 到 RAND_MAX 之间的整数值，RAND_MAX 通常为32767，通常和srand函数搭配使用
* void *malloc(size_t size)：分配内存空间，但不初始化。memory allocation
* void *calloc(size_t nmemb, size_t size)：为nmemb个元素分配内存空间，每个元素的长度是size，并且初始化清零。clear allocation
* void *realloc(void *ptr, size_t size)：调整已分配的内存空间大小，但不初始化。re-allocation
* void free(void *ptr)：释放内存空间
* void qsort(void \*base, size_t nmemb, size_t size, int (*compar) (const void *, const void *))：给任意数组排序
* 

## <string.h>

* char *trcpy(char * s1, const char *s2)：把字符串s2复制到字符串s1中，不考虑s1的大小
* strncpy
* size_t strlen(const char *s)：返回字符串s的长度
* char *strcat(char *s1, const char *s2)：把字符串s2的内容追加到字符串s1的末尾，不考虑s1的大小
* strncat
* int strcmp(const char *s1, const char *s2)：比较字符串s1和s2的大小，返回小于、等于、大于0的值
* void *memcpy(void * restrict s1, const void * restrict s2, size_t n)：
* void *memmove(void * s1, const void * s2, size_t n)：
* 

## <math.h>

* sin
* cos
* tan
* ceil



# 代码调试过程中的一些记录

## 为什么字符串的结尾要打印'\0'

通过gdb调试以下测试程序发现，如果结尾没有'\0'，可能引发一些意料之外的结果。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    // str
    char* str = "HelloWorld!";
    printf("str strlen: %d\n", strlen(str)); // 长度是11
    printf("str: %s\n", str);

    // str2 分配内存strlen(str) 末尾不增加\0
    char* str2 = malloc(strlen(str));
    for (int i = 0; i < strlen(str); i++) {
        str2[i] = str[i];
    }

    printf("str2 strlen: %d\n", strlen(str2)); // 长度不是11
    printf("str2: %s\n", str2); // 打印str2时，会打印到结束，有额外的空字符：HelloWorld!?

    // str3 分配内存strlen(str) + 1 末尾增加\0
    char* str3 = malloc(strlen(str) + 1);
    for (int i = 0; i < strlen(str); i++) {
        str3[i] = str[i];
    }
    str3[strlen(str)] = '\0';

    printf("str3 strlen: %d\n", strlen(str3)); // 长度是11
    printf("str3: %s\n", str3); // 打印str3时，会打印到\0结束，没有额外的空字符：HelloWorld!

    return 0;
}
```



